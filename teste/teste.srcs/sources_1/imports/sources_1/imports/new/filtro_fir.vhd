library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;

entity filtro_fir is
    GENERIC (n: INTEGER := 101; m: INTEGER := 16);
--  n é o número de coeficientes; m é o número de bits do coeficente e entrada
    PORT ( x: IN SIGNED(m-1 downto 0);
           clk, rst: IN STD_LOGIC;
           y: OUT SIGNED(2*m-1 downto 0));
end filtro_fir;

architecture rtl of filtro_fir is

    type registradores is array (n-2 downto 0) of signed (m-1 downto 0);
    type coeficientes is array (n-1 downto 0) of signed (m-1 downto 0);    
    signal reg: registradores;    
    constant coef: coeficientes := ("0000000000001111", "0000000000001111", "0000000000001111", "0000000000010000", 
                                    "0000000000010001", "0000000000010011", "0000000000010101", "0000000000010111", 
                                    "0000000000011001", "0000000000011100", "0000000000011111", "0000000000100010", 
                                    "0000000000100110", "0000000000101010", "0000000000101110", "0000000000110010", 
                                    "0000000000110110", "0000000000111011", "0000000001000000", "0000000001000101", 
                                    "0000000001001010", "0000000001001111", "0000000001010100", "0000000001011001", 
                                    "0000000001011111", "0000000001100100", "0000000001101001", "0000000001101111", 
                                    "0000000001110100", "0000000001111001", "0000000001111110", "0000000010000011", 
                                    "0000000010001000", "0000000010001101", "0000000010010001", "0000000010010110", 
                                    "0000000010011010", "0000000010011110", "0000000010100010", "0000000010100101", 
                                    "0000000010101001", "0000000010101100", "0000000010101110", "0000000010110001", 
                                    "0000000010110011", "0000000010110101", "0000000010110110", "0000000010110111", 
                                    "0000000010111000", "0000000010111001", "0000000010111001", "0000000010111001", 
                                    "0000000010111000", "0000000010110111", "0000000010110110", "0000000010110101", 
                                    "0000000010110011", "0000000010110001", "0000000010101110", "0000000010101100", 
                                    "0000000010101001", "0000000010100101", "0000000010100010", "0000000010011110", 
                                    "0000000010011010", "0000000010010110", "0000000010010001", "0000000010001101", 
                                    "0000000010001000", "0000000010000011", "0000000001111110", "0000000001111001", 
                                    "0000000001110100", "0000000001101111", "0000000001101001", "0000000001100100", 
                                    "0000000001011111", "0000000001011001", "0000000001010100", "0000000001001111", 
                                    "0000000001001010", "0000000001000101", "0000000001000000", "0000000000111011", 
                                    "0000000000110110", "0000000000110010", "0000000000101110", "0000000000101010", 
                                    "0000000000100110", "0000000000100010", "0000000000011111", "0000000000011100", 
                                    "0000000000011001", "0000000000010111", "0000000000010101", "0000000000010011", 
                                    "0000000000010001", "0000000000010000", "0000000000001111", "0000000000001111", 
                                    "0000000000001111");

begin

filtro: process (clk, rst)
    variable acc, prod: signed(2*m-1 downto 0) := (others => '0'); 
    variable sign: STD_LOGIC;
begin
    if (rst ='1') then
        for i in n-2 downto 0 loop
            for j in m-1 downto 0 loop
                reg(i)(j) <= '0';
            end loop;
        end loop;
        
    elsif (clk'event and clk = '1') then
        acc := coef(0)*x;
        for i in 1 to n-1 loop
            sign := acc(2*m-1);
            prod := coef(i)*reg(n-1-i);
            acc := acc + prod;
---------OVERFLOW-----------------
            if (sign=prod(prod'left)) and (acc(acc'left) /= sign) then
                acc := (acc'left => sign, others => not sign    );
            end if;
        end loop;        
        reg <= x & reg(n-2 downto 1);       
    end if;    
    y <= acc;        
end process;           
end rtl;
